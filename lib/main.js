// Generated by CoffeeScript 1.9.3
(function() {
  var BAP, BASE, EXTENSION, LODASH, TRM, TYPES, badge, rpr, warn;

  TYPES = require('coffeenode-types');

  LODASH = require('lodash');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'IDLX';

  warn = TRM.get_logger('warn', badge);

  BASE = require('./1-BASE');

  EXTENSION = require('./2-EXTENSION');

  BAP = require('coffeenode-bitsnpieces');

  this.parse = function(text) {
    return EXTENSION.expression.run(text);
  };

  this.correct_formula_ordering = function(formula) {

    /* In general, the ordering of components given in a IDL (Ideographic Description Language) formula for
    a given reflects the order in which those components are written, for example:
    
    * 信:  ⿰亻言
    * 冥:  (⿱冖日六)
    
    As long as this statement holds, it remains true when components are recursively replaced by their
    respective formulas; for example, the two glyphs given above can also be written:
    
    ```
    * 信:  ⿰亻言       -> ⿰亻言          ->   ⿰亻(⿱亠二口)
                                         ->  ⿰亻(⿱丶三口)
                                         ->  ⿰亻(⿱亠一𠮛)
    * 冥:  (⿱冖日六)    -> (⿱冖日亠八)
    ```
    
    Thus, formulas are an important tool to define not only which components are used to form glyphs, but also
    where they are placed inside the glyph.
    
    However, there are cases where IDL notations fail to reflect correct ordering:
    
    ```
    * 術:  ⿴行术         (correct order: 彳术亍)
    * 𠚍:  ⿶凵𠂭         (correct order: 𠂭凵)
    * 這:  ⿺辶言         (correct order: 言辶)
    * 建:  ⿺廴聿         (correct order: 聿廴)
    ```
    
    The last two cases are examples for the most frequent class of mis-ordering, and the only one that is
    currently addressed by `IDLX/correct_formula_ordering`. Here are sample outputs:
    
    * 這: ( IDLX.correct_formula_ordering '⿺辶言' ) gives '⿺言辶'
    * 建: ( IDLX.correct_formula_ordering '⿺廴聿' ) gives '⿺聿廴'
    ```
    
    At the time being, formulas that do not contain `辶` and/or `廴` are returned unchanged; this may change
    in the future.
    
    Note that the resulting formulas are not anymore geometrically correct; this is because appropriate IDL
    operators are lacking for these cases. The corrected formulas can, however, be used to determine the
    correct order of writing when one disregards the operators and keeps only the components. Thus:
    
    ```
    * 這: 言辶         ->  亠二口辶
                      ->  丶三口辶
                      ->  亠一𠮛辶
    ```
    are all correct descriptions of the character `這`.
     */
    var error;
    try {
      if (!this._naive_formula_matcher.test(formula)) {
        return formula;
      }
      return (LODASH.flatten(this._correct_formula_ordering(this.parse(formula)))).join('');
    } catch (_error) {
      error = _error;
      warn();
      warn('----------------------------------------------------------------------');
      warn("an error occurred when trying to parse formula " + (rpr(formula)) + ":");
      warn(error['message']);
      warn('----------------------------------------------------------------------');
      warn();
      throw error;
    }
  };

  this._correct_formula_ordering = function(elements) {
    var element, idx, last_idx, ref, sub_element;
    idx = -1;
    last_idx = elements.length - 1;
    while (true) {
      idx += 1;
      element = elements[idx];
      if (TYPES.isa_list(element)) {
        this._correct_formula_ordering(element);
        continue;
      }
      if (this._naive_formula_matcher.test(element)) {
        ref = [elements[idx + 1], elements[idx]], elements[idx] = ref[0], elements[idx + 1] = ref[1];
        if (TYPES.isa_list((sub_element = elements[idx]))) {
          this._correct_formula_ordering(sub_element);
        }
        idx += 1;
      }
      if (idx >= last_idx) {
        break;
      }
    }
    return elements;
  };

  this._naive_formula_matcher = /辶|廴/;

  this.find_all_cjk_chrs = function(text) {
    return BAP.find_all(text, BASE.$['cjk-chr']);
  };

  this.find_all_non_operators = function(text) {
    return BAP.find_all(text, BASE.cjkg_chr_matcher);
  };

}).call(this);

//# sourceMappingURL=main.js.map
