// Generated by CoffeeScript 1.7.1
(function() {
  var $new, BASE, BNP, TRM, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'IDLX/XXXXXXXX';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  BNP = require('coffeenode-bitsnpieces');

  ƒ = require('flowmatic');

  $new = ƒ["new"];

  BASE = require('./1-BASE');

  this.options = {
    'operator-2': /[⿰⿱⿴⿵⿶⿷⿸⿹⿺⿻◰]/,
    'operator-1': /[↻↔↕]/
  };

  this.constructor = function(G, $) {
    G.expression = function() {
      return ƒ.or((function() {
        return BASE.$finish;
      }), (function() {
        return G.formula;
      }));
    };
    G.formula = function() {
      return ƒ.or((function() {
        return G.formula_bracketed;
      }), (function() {
        return G.formula_plain;
      }), (function() {
        return BASE.missing;
      }));
    };
    G.formula_plain = function() {
      return ƒ.or((function() {
        return G.formula_binary;
      }), (function() {
        return G.formula_unary;
      }));
    };
    G.formula_unary = function() {
      return ƒ.seq((function() {
        return G.operator_1;
      }), (function() {
        return G.term;
      }));
    };
    G.formula_binary = function() {
      return ƒ.seq((function() {
        return G.operator_2;
      }), (function() {
        return G.term;
      }), (function() {
        return G.term;
      }));
    };
    G.term = function() {
      return ƒ.or((function() {
        return G.term_precise;
      }), (function() {
        return G.term_similar;
      }));
    };
    G.terms = function() {
      return ƒ.repeat((function() {
        return G.term;
      }), 1);
    };
    G.term_precise = function() {
      return ƒ.or((function() {
        return G.formula;
      }), (function() {
        return G.component;
      }));
    };
    G.term_similar = function() {
      return ƒ.seq((function() {
        return ƒ.string(BASE.$['similarity-mark']);
      }), (function() {
        return G.term_precise;
      }));
    };
    G.component = function() {
      return ƒ.or((function() {
        return BASE.$cjk_chr;
      }), (function() {
        return BASE.$ncr;
      }), (function() {
        return BASE.$curvy_line;
      }));
    };
    G.operator_1 = ƒ.or(function() {
      return ƒ.regex($['operator-1']);
    }).onMatch(function(match, state) {
      return match[0];
    });
    G.operator_2 = ƒ.or(function() {
      return ƒ.regex($['operator-2']);
    }).onMatch(function(match, state) {
      return match[0];
    }).describe('EXTENSION/operator-2');
    G.formula_bracketed = ƒ.seq(ƒ.string('('), (function() {
      return G.operator_2;
    }), (function() {
      return G.terms;
    }), ƒ.string(')')).onMatch(function(match, state) {
      return match.slice(1, match.length - 1);
    });
    G.tests['unary formula'] = function(test) {
      var matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['↔正', ['↔', '正']], ['↻正', ['↻', '正']], ['↔≈匕', ['↔', ['≈', '匕']]]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.formula_unary.run(probe));
        debug(result);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    G.tests['binary formula'] = function(test) {
      var matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['⿱丶乂', ['⿱', '丶', '乂']], ['⿺走⿹◰口戈日', ['⿺', '走', ['⿹', ['◰', '口', '戈'], '日']]]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.formula_binary.run(probe));
        debug(result);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    G.tests['plain formula'] = function(test) {
      var matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['↻正', ['↻', '正']], ['↔≈匕', ['↔', ['≈', '匕']]], ['↔正', ['↔', '正']], ['⿱丶乂', ['⿱', '丶', '乂']], ['⿺走⿹◰口戈日', ['⿺', '走', ['⿹', ['◰', '口', '戈'], '日']]]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.formula_plain.run(probe));
        debug(result);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    G.tests['bracketed formula'] = function(test) {
      var matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['(⿱北㓁允)', ['⿱', ['北', '㓁', '允']]]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.formula_bracketed.run(probe));
        debug(result);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    G.tests['formula'] = function(test) {
      var matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['↻正', ['↻', '正']], ['↔≈匕', ['↔', ['≈', '匕']]], ['↔正', ['↔', '正']], ['⿱丶乂', ['⿱', '丶', '乂']], ['⿺走⿹◰口戈日', ['⿺', '走', ['⿹', ['◰', '口', '戈'], '日']]], ['(⿱北㓁允)', ['⿱', ['北', '㓁', '允']]]];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.formula.run(probe));
        debug(result);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
    return G.tests['expression'] = function(test) {
      var matcher, probe, probes_and_matchers, result, _i, _len, _ref, _results;
      probes_and_matchers = [['↻正', ['↻', '正']], ['↔≈匕', ['↔', ['≈', '匕']]], ['↔正', ['↔', '正']], ['⿱丶乂', ['⿱', '丶', '乂']], ['⿺走⿹◰口戈日', ['⿺', '走', ['⿹', ['◰', '口', '戈'], '日']]], ['(⿱北㓁允)', ['⿱', ['北', '㓁', '允']]], ['●', '●']];
      _results = [];
      for (_i = 0, _len = probes_and_matchers.length; _i < _len; _i++) {
        _ref = probes_and_matchers[_i], probe = _ref[0], matcher = _ref[1];
        result = ƒ["new"]._delete_grammar_references(G.expression.run(probe));
        debug(result);
        _results.push(test.eq(result, matcher));
      }
      return _results;
    };
  };

  ƒ["new"].consolidate(this);

}).call(this);
