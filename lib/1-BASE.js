// Generated by CoffeeScript 1.10.0
(function() {
  var $new, BNP, TRM, alert, badge, debug, echo, help, info, log, rainbow, rpr, warn, whisper, ƒ;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'IDLX/1-BASE';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  BNP = require('coffeenode-bitsnpieces');

  ƒ = require('flowmatic');

  $new = ƒ["new"];

  this.cjk_chr_matcher = /[\u2e80-\u2eff\u2f00-\u2fdf\u3005-\u3007\u3013\u3021-\u3029\u3038-\u303d\u31c0-\u31ef\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff]|(?:[\ud840-\ud868][\udc00-\udfff]|\ud869[\udc00-\uded6])|(?:[\ud86a-\ud86c][\udc00-\udfff]|\ud869[\udf00-\udfff]|\ud86d[\udc00-\udf3f])|(?:\ud86d[\udf40-\udfff]|\ud86e[\udc00-\udc1d])|(?:\ud87e[\udc00-\ude1d])/g;

  this.options = {
    'finish-formula': '●',
    'missing-formula': '〓',
    'mapped-cp': '▽',
    'ncr': /&[a-z0-9]*\#(?:x[a-f0-9]+|[0-9]+);/,
    'operator-2': /[⿰⿱⿴⿵⿶⿷⿸⿹⿺⿻]/,
    'operator-3': /[⿲⿳]/,
    'similarity-mark': '≈',
    'curvy-line': '§',
    'cjk-chr': this.cjk_chr_matcher
  };

  this.cjkg_chr_matcher = RegExp(this.options['missing-formula'] + "|" + this.options['curvy-line'] + "|(?:" + this.options['ncr'].source + ")|(?:" + this.cjk_chr_matcher.source + ")", "g");

  this.constructor = function(G, $) {
    G.$curvy_line = function() {
      return ƒ.or(ƒ.string($['curvy-line']));
    };
    G.$finish = function() {
      return ƒ.or(ƒ.string($['finish-formula']));
    };
    G.component = function() {
      return ƒ.or((function() {
        return G.$cjk_chr;
      }), (function() {
        return G.$ncr;
      }), (function() {
        return G.$curvy_line;
      }));
    };
    G.expression = function() {
      return ƒ.or((function() {
        return G.$finish;
      }), (function() {
        return G.formula;
      }));
    };
    G.formula = function() {
      return ƒ.or((function() {
        return G.formula_3;
      }), (function() {
        return G.formula_2;
      }), (function() {
        return G.missing;
      }));
    };
    G.formula_2 = function() {
      return ƒ.seq((function() {
        return G.$operator_2;
      }), (function() {
        return G.term;
      }), (function() {
        return G.term;
      }));
    };
    G.formula_3 = function() {
      return ƒ.seq((function() {
        return G.$operator_3;
      }), (function() {
        return G.term;
      }), (function() {
        return G.term;
      }), (function() {
        return G.term;
      }));
    };
    G.missing = function() {
      return ƒ.or(ƒ.string($['missing-formula']));
    };
    G.term = function() {
      return ƒ.or((function() {
        return G.term_precise;
      }), (function() {
        return G.term_similar;
      }));
    };
    G.term_precise = function() {
      return ƒ.or((function() {
        return G.formula;
      }), (function() {
        return G.component;
      }));
    };
    G.term_similar = function() {
      return ƒ.seq(ƒ.string($['similarity-mark']), (function() {
        return G.term_precise;
      }));
    };
    G.$ncr = ƒ.or(function() {
      return ƒ.regex($['ncr']);
    }).onMatch(function(match, state) {
      return match[0];
    });
    G.$cjk_chr = ƒ.or(function() {
      return ƒ.regex($['cjk-chr']);
    }).onMatch(function(match, state) {
      return match[0];
    });
    G.$operator_2 = ƒ.or(function() {
      return ƒ.regex($['operator-2']);
    }).onMatch(function(match, state) {
      return match[0];
    });
    G.$operator_3 = ƒ.or(function() {
      return ƒ.regex($['operator-3']);
    }).onMatch(function(match, state) {
      return match[0];
    }).describe('BASE/operator-3');
    G.tests['operator 2'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['⿰', '⿰'], ['⿴', '⿴']];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.$operator_2.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
    G.tests['operator 3'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['⿳', '⿳']];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.$operator_3.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
    G.tests['CJK character'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['㐀', '㐀'], ['𠀎', '𠀎'], ['𪜀', '𪜀'], ['〇', '〇']];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.$cjk_chr.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
    G.tests['similarity term'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['≈㐀', ['≈', '㐀']], ['≈𠀎', ['≈', '𠀎']], ['≈𪜀', ['≈', '𪜀']], ['≈〇', ['≈', '〇']]];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.term_similar.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
    G.tests['precise term'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['⿻串一', ['⿻', '串', '一']]];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.term_precise.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
    G.tests['formula 2'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['⿻串一', ['⿻', '串', '一']], ['⿻串⿰立风', ['⿻', '串', ['⿰', '立', '风']]], ['⿻串⿰立&jzr#x1234;', ['⿻', '串', ['⿰', '立', '&jzr#x1234;']]], ['⿻串⿳立风𠃓', ['⿻', '串', ['⿳', '立', '风', '𠃓']]]];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.formula_2.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
    G.tests['formula 3'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['⿳立风𠃓', ['⿳', '立', '风', '𠃓']]];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.formula_3.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
    G.tests['formula'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['⿻串一', ['⿻', '串', '一']], ['⿻串⿰立风', ['⿻', '串', ['⿰', '立', '风']]], ['⿻串⿳立风𠃓', ['⿻', '串', ['⿳', '立', '风', '𠃓']]]];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.formula.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
    return G.tests['expression'] = function(test) {
      var i, len, matcher, probe, probes_and_matchers, ref, result, results;
      probes_and_matchers = [['⿻串一', ['⿻', '串', '一']], ['⿻串⿰立风', ['⿻', '串', ['⿰', '立', '风']]], ['⿻串⿳立风𠃓', ['⿻', '串', ['⿳', '立', '风', '𠃓']]], ['●', '●']];
      results = [];
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        result = ƒ["new"]._delete_grammar_references(G.expression.run(probe));
        results.push(test.eq(result, matcher));
      }
      return results;
    };
  };

  ƒ["new"].consolidate(this);

}).call(this);
